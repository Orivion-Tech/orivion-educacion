{"ast":null,"code":"'use strict';\n\nconst doctype = require('parse5/lib/common/doctype');\nconst {\n  DOCUMENT_MODE\n} = require('parse5/lib/common/html');\n\n//Conversion tables for DOM Level1 structure emulation\nconst nodeTypes = {\n  element: 1,\n  text: 3,\n  cdata: 4,\n  comment: 8\n};\nconst nodePropertyShorthands = {\n  tagName: 'name',\n  childNodes: 'children',\n  parentNode: 'parent',\n  previousSibling: 'prev',\n  nextSibling: 'next',\n  nodeValue: 'data'\n};\n\n//Node\nclass Node {\n  constructor(props) {\n    for (const key of Object.keys(props)) {\n      this[key] = props[key];\n    }\n  }\n  get firstChild() {\n    const children = this.children;\n    return children && children[0] || null;\n  }\n  get lastChild() {\n    const children = this.children;\n    return children && children[children.length - 1] || null;\n  }\n  get nodeType() {\n    return nodeTypes[this.type] || nodeTypes.element;\n  }\n}\nObject.keys(nodePropertyShorthands).forEach(key => {\n  const shorthand = nodePropertyShorthands[key];\n  Object.defineProperty(Node.prototype, key, {\n    get: function () {\n      return this[shorthand] || null;\n    },\n    set: function (val) {\n      this[shorthand] = val;\n      return val;\n    }\n  });\n});\n\n//Node construction\nexports.createDocument = function () {\n  return new Node({\n    type: 'root',\n    name: 'root',\n    parent: null,\n    prev: null,\n    next: null,\n    children: [],\n    'x-mode': DOCUMENT_MODE.NO_QUIRKS\n  });\n};\nexports.createDocumentFragment = function () {\n  return new Node({\n    type: 'root',\n    name: 'root',\n    parent: null,\n    prev: null,\n    next: null,\n    children: []\n  });\n};\nexports.createElement = function (tagName, namespaceURI, attrs) {\n  const attribs = Object.create(null);\n  const attribsNamespace = Object.create(null);\n  const attribsPrefix = Object.create(null);\n  for (let i = 0; i < attrs.length; i++) {\n    const attrName = attrs[i].name;\n    attribs[attrName] = attrs[i].value;\n    attribsNamespace[attrName] = attrs[i].namespace;\n    attribsPrefix[attrName] = attrs[i].prefix;\n  }\n  return new Node({\n    type: tagName === 'script' || tagName === 'style' ? tagName : 'tag',\n    name: tagName,\n    namespace: namespaceURI,\n    attribs: attribs,\n    'x-attribsNamespace': attribsNamespace,\n    'x-attribsPrefix': attribsPrefix,\n    children: [],\n    parent: null,\n    prev: null,\n    next: null\n  });\n};\nexports.createCommentNode = function (data) {\n  return new Node({\n    type: 'comment',\n    data: data,\n    parent: null,\n    prev: null,\n    next: null\n  });\n};\nconst createTextNode = function (value) {\n  return new Node({\n    type: 'text',\n    data: value,\n    parent: null,\n    prev: null,\n    next: null\n  });\n};\n\n//Tree mutation\nconst appendChild = exports.appendChild = function (parentNode, newNode) {\n  const prev = parentNode.children[parentNode.children.length - 1];\n  if (prev) {\n    prev.next = newNode;\n    newNode.prev = prev;\n  }\n  parentNode.children.push(newNode);\n  newNode.parent = parentNode;\n};\nconst insertBefore = exports.insertBefore = function (parentNode, newNode, referenceNode) {\n  const insertionIdx = parentNode.children.indexOf(referenceNode);\n  const prev = referenceNode.prev;\n  if (prev) {\n    prev.next = newNode;\n    newNode.prev = prev;\n  }\n  referenceNode.prev = newNode;\n  newNode.next = referenceNode;\n  parentNode.children.splice(insertionIdx, 0, newNode);\n  newNode.parent = parentNode;\n};\nexports.setTemplateContent = function (templateElement, contentElement) {\n  appendChild(templateElement, contentElement);\n};\nexports.getTemplateContent = function (templateElement) {\n  return templateElement.children[0];\n};\nexports.setDocumentType = function (document, name, publicId, systemId) {\n  const data = doctype.serializeContent(name, publicId, systemId);\n  let doctypeNode = null;\n  for (let i = 0; i < document.children.length; i++) {\n    if (document.children[i].type === 'directive' && document.children[i].name === '!doctype') {\n      doctypeNode = document.children[i];\n      break;\n    }\n  }\n  if (doctypeNode) {\n    doctypeNode.data = data;\n    doctypeNode['x-name'] = name;\n    doctypeNode['x-publicId'] = publicId;\n    doctypeNode['x-systemId'] = systemId;\n  } else {\n    appendChild(document, new Node({\n      type: 'directive',\n      name: '!doctype',\n      data: data,\n      'x-name': name,\n      'x-publicId': publicId,\n      'x-systemId': systemId\n    }));\n  }\n};\nexports.setDocumentMode = function (document, mode) {\n  document['x-mode'] = mode;\n};\nexports.getDocumentMode = function (document) {\n  return document['x-mode'];\n};\nexports.detachNode = function (node) {\n  if (node.parent) {\n    const idx = node.parent.children.indexOf(node);\n    const prev = node.prev;\n    const next = node.next;\n    node.prev = null;\n    node.next = null;\n    if (prev) {\n      prev.next = next;\n    }\n    if (next) {\n      next.prev = prev;\n    }\n    node.parent.children.splice(idx, 1);\n    node.parent = null;\n  }\n};\nexports.insertText = function (parentNode, text) {\n  const lastChild = parentNode.children[parentNode.children.length - 1];\n  if (lastChild && lastChild.type === 'text') {\n    lastChild.data += text;\n  } else {\n    appendChild(parentNode, createTextNode(text));\n  }\n};\nexports.insertTextBefore = function (parentNode, text, referenceNode) {\n  const prevNode = parentNode.children[parentNode.children.indexOf(referenceNode) - 1];\n  if (prevNode && prevNode.type === 'text') {\n    prevNode.data += text;\n  } else {\n    insertBefore(parentNode, createTextNode(text), referenceNode);\n  }\n};\nexports.adoptAttributes = function (recipient, attrs) {\n  for (let i = 0; i < attrs.length; i++) {\n    const attrName = attrs[i].name;\n    if (typeof recipient.attribs[attrName] === 'undefined') {\n      recipient.attribs[attrName] = attrs[i].value;\n      recipient['x-attribsNamespace'][attrName] = attrs[i].namespace;\n      recipient['x-attribsPrefix'][attrName] = attrs[i].prefix;\n    }\n  }\n};\n\n//Tree traversing\nexports.getFirstChild = function (node) {\n  return node.children[0];\n};\nexports.getChildNodes = function (node) {\n  return node.children;\n};\nexports.getParentNode = function (node) {\n  return node.parent;\n};\nexports.getAttrList = function (element) {\n  const attrList = [];\n  for (const name in element.attribs) {\n    attrList.push({\n      name: name,\n      value: element.attribs[name],\n      namespace: element['x-attribsNamespace'][name],\n      prefix: element['x-attribsPrefix'][name]\n    });\n  }\n  return attrList;\n};\n\n//Node data\nexports.getTagName = function (element) {\n  return element.name;\n};\nexports.getNamespaceURI = function (element) {\n  return element.namespace;\n};\nexports.getTextNodeContent = function (textNode) {\n  return textNode.data;\n};\nexports.getCommentNodeContent = function (commentNode) {\n  return commentNode.data;\n};\nexports.getDocumentTypeNodeName = function (doctypeNode) {\n  return doctypeNode['x-name'];\n};\nexports.getDocumentTypeNodePublicId = function (doctypeNode) {\n  return doctypeNode['x-publicId'];\n};\nexports.getDocumentTypeNodeSystemId = function (doctypeNode) {\n  return doctypeNode['x-systemId'];\n};\n\n//Node types\nexports.isTextNode = function (node) {\n  return node.type === 'text';\n};\nexports.isCommentNode = function (node) {\n  return node.type === 'comment';\n};\nexports.isDocumentTypeNode = function (node) {\n  return node.type === 'directive' && node.name === '!doctype';\n};\nexports.isElementNode = function (node) {\n  return !!node.attribs;\n};\n\n// Source code location\nexports.setNodeSourceCodeLocation = function (node, location) {\n  node.sourceCodeLocation = location;\n};\nexports.getNodeSourceCodeLocation = function (node) {\n  return node.sourceCodeLocation;\n};\nexports.updateNodeSourceCodeLocation = function (node, endLocation) {\n  node.sourceCodeLocation = Object.assign(node.sourceCodeLocation, endLocation);\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}