{"ast":null,"code":"'use strict';\n\nlet CssSyntaxError = require('./css-syntax-error');\nlet Stringifier = require('./stringifier');\nlet stringify = require('./stringify');\nlet {\n  isClean,\n  my\n} = require('./symbols');\nfunction cloneNode(obj, parent) {\n  let cloned = new obj.constructor();\n  for (let i in obj) {\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) {\n      /* c8 ignore next 2 */\n      continue;\n    }\n    if (i === 'proxyCache') continue;\n    let value = obj[i];\n    let type = typeof value;\n    if (i === 'parent' && type === 'object') {\n      if (parent) cloned[i] = parent;\n    } else if (i === 'source') {\n      cloned[i] = value;\n    } else if (Array.isArray(value)) {\n      cloned[i] = value.map(j => cloneNode(j, cloned));\n    } else {\n      if (type === 'object' && value !== null) value = cloneNode(value);\n      cloned[i] = value;\n    }\n  }\n  return cloned;\n}\nfunction sourceOffset(inputCSS, position) {\n  // Not all custom syntaxes support `offset` in `source.start` and `source.end`\n  if (position && typeof position.offset !== 'undefined') {\n    return position.offset;\n  }\n  let column = 1;\n  let line = 1;\n  let offset = 0;\n  for (let i = 0; i < inputCSS.length; i++) {\n    if (line === position.line && column === position.column) {\n      offset = i;\n      break;\n    }\n    if (inputCSS[i] === '\\n') {\n      column = 1;\n      line += 1;\n    } else {\n      column += 1;\n    }\n  }\n  return offset;\n}\nclass Node {\n  get proxyOf() {\n    return this;\n  }\n  constructor(defaults = {}) {\n    this.raws = {};\n    this[isClean] = false;\n    this[my] = true;\n    for (let name in defaults) {\n      if (name === 'nodes') {\n        this.nodes = [];\n        for (let node of defaults[name]) {\n          if (typeof node.clone === 'function') {\n            this.append(node.clone());\n          } else {\n            this.append(node);\n          }\n        }\n      } else {\n        this[name] = defaults[name];\n      }\n    }\n  }\n  addToError(error) {\n    error.postcssNode = this;\n    if (error.stack && this.source && /\\n\\s{4}at /.test(error.stack)) {\n      let s = this.source;\n      error.stack = error.stack.replace(/\\n\\s{4}at /, `$&${s.input.from}:${s.start.line}:${s.start.column}$&`);\n    }\n    return error;\n  }\n  after(add) {\n    this.parent.insertAfter(this, add);\n    return this;\n  }\n  assign(overrides = {}) {\n    for (let name in overrides) {\n      this[name] = overrides[name];\n    }\n    return this;\n  }\n  before(add) {\n    this.parent.insertBefore(this, add);\n    return this;\n  }\n  cleanRaws(keepBetween) {\n    delete this.raws.before;\n    delete this.raws.after;\n    if (!keepBetween) delete this.raws.between;\n  }\n  clone(overrides = {}) {\n    let cloned = cloneNode(this);\n    for (let name in overrides) {\n      cloned[name] = overrides[name];\n    }\n    return cloned;\n  }\n  cloneAfter(overrides = {}) {\n    let cloned = this.clone(overrides);\n    this.parent.insertAfter(this, cloned);\n    return cloned;\n  }\n  cloneBefore(overrides = {}) {\n    let cloned = this.clone(overrides);\n    this.parent.insertBefore(this, cloned);\n    return cloned;\n  }\n  error(message, opts = {}) {\n    if (this.source) {\n      let {\n        end,\n        start\n      } = this.rangeBy(opts);\n      return this.source.input.error(message, {\n        column: start.column,\n        line: start.line\n      }, {\n        column: end.column,\n        line: end.line\n      }, opts);\n    }\n    return new CssSyntaxError(message);\n  }\n  getProxyProcessor() {\n    return {\n      get(node, prop) {\n        if (prop === 'proxyOf') {\n          return node;\n        } else if (prop === 'root') {\n          return () => node.root().toProxy();\n        } else {\n          return node[prop];\n        }\n      },\n      set(node, prop, value) {\n        if (node[prop] === value) return true;\n        node[prop] = value;\n        if (prop === 'prop' || prop === 'value' || prop === 'name' || prop === 'params' || prop === 'important' || /* c8 ignore next */\n        prop === 'text') {\n          node.markDirty();\n        }\n        return true;\n      }\n    };\n  }\n\n  /* c8 ignore next 3 */\n  markClean() {\n    this[isClean] = true;\n  }\n  markDirty() {\n    if (this[isClean]) {\n      this[isClean] = false;\n      let next = this;\n      while (next = next.parent) {\n        next[isClean] = false;\n      }\n    }\n  }\n  next() {\n    if (!this.parent) return undefined;\n    let index = this.parent.index(this);\n    return this.parent.nodes[index + 1];\n  }\n  positionBy(opts = {}) {\n    let pos = this.source.start;\n    if (opts.index) {\n      pos = this.positionInside(opts.index);\n    } else if (opts.word) {\n      let inputString = 'document' in this.source.input ? this.source.input.document : this.source.input.css;\n      let stringRepresentation = inputString.slice(sourceOffset(inputString, this.source.start), sourceOffset(inputString, this.source.end));\n      let index = stringRepresentation.indexOf(opts.word);\n      if (index !== -1) pos = this.positionInside(index);\n    }\n    return pos;\n  }\n  positionInside(index) {\n    let column = this.source.start.column;\n    let line = this.source.start.line;\n    let inputString = 'document' in this.source.input ? this.source.input.document : this.source.input.css;\n    let offset = sourceOffset(inputString, this.source.start);\n    let end = offset + index;\n    for (let i = offset; i < end; i++) {\n      if (inputString[i] === '\\n') {\n        column = 1;\n        line += 1;\n      } else {\n        column += 1;\n      }\n    }\n    return {\n      column,\n      line,\n      offset: end\n    };\n  }\n  prev() {\n    if (!this.parent) return undefined;\n    let index = this.parent.index(this);\n    return this.parent.nodes[index - 1];\n  }\n  rangeBy(opts = {}) {\n    let inputString = 'document' in this.source.input ? this.source.input.document : this.source.input.css;\n    let start = {\n      column: this.source.start.column,\n      line: this.source.start.line,\n      offset: sourceOffset(inputString, this.source.start)\n    };\n    let end = this.source.end ? {\n      column: this.source.end.column + 1,\n      line: this.source.end.line,\n      offset: typeof this.source.end.offset === 'number' ?\n      // `source.end.offset` is exclusive, so we don't need to add 1\n      this.source.end.offset :\n      // Since line/column in this.source.end is inclusive,\n      // the `sourceOffset(... , this.source.end)` returns an inclusive offset.\n      // So, we add 1 to convert it to exclusive.\n      sourceOffset(inputString, this.source.end) + 1\n    } : {\n      column: start.column + 1,\n      line: start.line,\n      offset: start.offset + 1\n    };\n    if (opts.word) {\n      let stringRepresentation = inputString.slice(sourceOffset(inputString, this.source.start), sourceOffset(inputString, this.source.end));\n      let index = stringRepresentation.indexOf(opts.word);\n      if (index !== -1) {\n        start = this.positionInside(index);\n        end = this.positionInside(index + opts.word.length);\n      }\n    } else {\n      if (opts.start) {\n        start = {\n          column: opts.start.column,\n          line: opts.start.line,\n          offset: sourceOffset(inputString, opts.start)\n        };\n      } else if (opts.index) {\n        start = this.positionInside(opts.index);\n      }\n      if (opts.end) {\n        end = {\n          column: opts.end.column,\n          line: opts.end.line,\n          offset: sourceOffset(inputString, opts.end)\n        };\n      } else if (typeof opts.endIndex === 'number') {\n        end = this.positionInside(opts.endIndex);\n      } else if (opts.index) {\n        end = this.positionInside(opts.index + 1);\n      }\n    }\n    if (end.line < start.line || end.line === start.line && end.column <= start.column) {\n      end = {\n        column: start.column + 1,\n        line: start.line,\n        offset: start.offset + 1\n      };\n    }\n    return {\n      end,\n      start\n    };\n  }\n  raw(prop, defaultType) {\n    let str = new Stringifier();\n    return str.raw(this, prop, defaultType);\n  }\n  remove() {\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n    this.parent = undefined;\n    return this;\n  }\n  replaceWith(...nodes) {\n    if (this.parent) {\n      let bookmark = this;\n      let foundSelf = false;\n      for (let node of nodes) {\n        if (node === this) {\n          foundSelf = true;\n        } else if (foundSelf) {\n          this.parent.insertAfter(bookmark, node);\n          bookmark = node;\n        } else {\n          this.parent.insertBefore(bookmark, node);\n        }\n      }\n      if (!foundSelf) {\n        this.remove();\n      }\n    }\n    return this;\n  }\n  root() {\n    let result = this;\n    while (result.parent && result.parent.type !== 'document') {\n      result = result.parent;\n    }\n    return result;\n  }\n  toJSON(_, inputs) {\n    let fixed = {};\n    let emitInputs = inputs == null;\n    inputs = inputs || new Map();\n    let inputsNextIndex = 0;\n    for (let name in this) {\n      if (!Object.prototype.hasOwnProperty.call(this, name)) {\n        /* c8 ignore next 2 */\n        continue;\n      }\n      if (name === 'parent' || name === 'proxyCache') continue;\n      let value = this[name];\n      if (Array.isArray(value)) {\n        fixed[name] = value.map(i => {\n          if (typeof i === 'object' && i.toJSON) {\n            return i.toJSON(null, inputs);\n          } else {\n            return i;\n          }\n        });\n      } else if (typeof value === 'object' && value.toJSON) {\n        fixed[name] = value.toJSON(null, inputs);\n      } else if (name === 'source') {\n        if (value == null) continue;\n        let inputId = inputs.get(value.input);\n        if (inputId == null) {\n          inputId = inputsNextIndex;\n          inputs.set(value.input, inputsNextIndex);\n          inputsNextIndex++;\n        }\n        fixed[name] = {\n          end: value.end,\n          inputId,\n          start: value.start\n        };\n      } else {\n        fixed[name] = value;\n      }\n    }\n    if (emitInputs) {\n      fixed.inputs = [...inputs.keys()].map(input => input.toJSON());\n    }\n    return fixed;\n  }\n  toProxy() {\n    if (!this.proxyCache) {\n      this.proxyCache = new Proxy(this, this.getProxyProcessor());\n    }\n    return this.proxyCache;\n  }\n  toString(stringifier = stringify) {\n    if (stringifier.stringify) stringifier = stringifier.stringify;\n    let result = '';\n    stringifier(this, i => {\n      result += i;\n    });\n    return result;\n  }\n  warn(result, text, opts = {}) {\n    let data = {\n      node: this\n    };\n    for (let i in opts) data[i] = opts[i];\n    return result.warn(text, data);\n  }\n}\nmodule.exports = Node;\nNode.default = Node;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}